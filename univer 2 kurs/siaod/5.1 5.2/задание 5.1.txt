Привет реализуй программу на c++ с комментариями на русском языке что делает каждая строка.
Пример – как установить 5-й бит произвольного целого числа в 0 и что получится в результате:
unsigned char x=255; //8-разрядное двоичное число 11111111
unsigned char maska = 1; //1=00000001 – 8-разрядная маска
x = x & (~ (maska<<4)); //результат x=239
Листинг 1
unsigned int x = 25;
const int n = sizeof(int) * 8; // = 32 - количество разрядов в числе типа int
unsigned maska = (1 << n - 1); // 1 в старшем бите 32-разрядной сетки
cout << "Начальный вид маски: " << bitset<n>(maska) << endl;
cout << "Результат: ";
for (int i = 1; i <= n; i++) // 32 раза по количеству разрядов: 
{
    cout << ((x & maska) >> (n - i));
    maska = maska >> 1; // смещение 1 в маске на разряд вправо 
}
cout << endl;
system("pause");
return 0;
Примечание: как видно из примера (строка 16 листинга 1), битовый массив можно организовать
и другими способами: с помощью класса bitset или класса vector из элементов типа bool.
Задание 1:
1.а. Реализуйте вышеприведённый пример, проверьте правильность результата в том числе и на
других значениях х.
1.б. Реализуйте по аналогии с предыдущим примером установку 7-го бита числа в единицу.
1.в. Реализуйте код листинга 1, объясните выводимый программой результат.

2. Сортировка последовательности чисел с помощью битового массива.
Пусть даны не более 8 чисел со значениями от 0 до 7, например, {1, 0, 5, 7, 2, 4}.
Подобный набор чисел удобно отразить в виде 8-разрядной битовой последовательности
11101101. В ней единичные биты показывают наличие в исходном наборе числа, равного номеру
этого бита в последовательности (нумерация с 0 слева). Т.о. индексы единичных битов в битовом
массиве – это и есть числа исходной последовательности.
Последовательное считывание бит этой последовательности и вывод индексов единичных
битов позволит естественным образом получить исходный набор чисел в отсортированном
виде – {0, 1, 2, 4, 5, 7}.
В качестве подобного битового массива удобно использовать беззнаковое однобайтовое
число (его двоичное представление в памяти), например, типа unsigned char. Приёмы работы с
отдельными битами числа были рассмотрены в предыдущем задании.
Задание 2:
2.а. Реализуйте вышеописанный пример с вводом произвольного набора до 8-ми чисел (со зна-
чениями от 0 до 7) и его сортировкой битовым массивом в виде числа типа unsigned char. Про-
верьте работу программы.
Если количество чисел в исходной последовательности больше 8 и/или значения превос-
ходят 7, можно подобрать тип беззнакового числа для битового массива с подходящим размером
разрядной сетки – до 64 в типе unsigned long long (см. табл. 1).
2.б. Адаптируйте вышеприведённый пример для набора из 64-х чисел (со значениями от 0 до 63)
с битовым массивом в виде числа типа unsigned long long.
Если количество чисел и/или их значения превосходят возможности разрядной сетки од-
ного беззнакового целого числа, то можно организовать линейный массив (вектор) таких чисел,
который в памяти ЭВМ будет представлен одной непрерывной битовой последовательностью.
2.в. Исправьте программу задания 2.б, чтобы для сортировки набора из 64-х чисел использова-
лось не одно число типа unsigned long long, а линейный массив чисел типа unsigned char.

3. Быстрая сортировка числового файла с помощью битового массива.
На практике может возникнуть задача внешней сортировки, т.е. упорядочения значений,
расположенных во внешней памяти компьютера, размер которых превышает допустимый объём
ОЗУ (например, 1 МБ стека, выделяемый по умолчанию программе операционной системой).
Возможный способ – это алгоритм внешней сортировки слиянием, рассмотренный в од-
ной из предыдущих практических работ. Считывание исходного файла при этом происходит
один раз, но в процессе сортировки создаются и многократно считываются вспомогательные
файлы, что существенно снижает быстродействие.
Второй возможный приём – считывание входного файла порциями, размер каждой из ко-
торых не превышает лимит ОЗУ. Результат записывается в выходной файл за один раз, при этом
не используются вспомогательные файлы. Программа будет работать быстрее, но всё-таки есть
алгоритм, существенно превосходящий перечисленные.
Реализовать высокоэффективную сортировку большого объёма числовых данных в файле
можно на идее битового массива. Достаточно один раз считать содержимое файла, заполнив при
этом в памяти ЭВМ битовый массив и на его основе быстро сформировать содержимое выход-
ного файла в уже отсортированном виде.
При использовании битового массива для представления сортируемых чисел, программу
можно представить как последовательность из трех подзадач:
а) Создание битового массива с нулевыми исходными значениями.
б) Считывание целых чисел из файла и установка в 1 соответствующих бит массива.
в) Формирование упорядоченного выходного файла путём последовательной проверки бит мас-
сива и вывода в файл номеров (индексов) тех бит, которые установлены в 1.

Задание 3.
Постановка задачи:
Входные данные: файл, содержащий не более n=107 неотрицательных целых чисел2, среди них
нет повторяющихся.
Результат: упорядоченная по возрастанию последовательность исходных чисел в выходном
файле.
Время работы программы: ~10 с (до 1 мин. для систем малой вычислительной мощности).
Максимально допустимый объём ОЗУ для хранения данных: 1 МБ.
Очевидно, что размер входных данных гарантированно превысит 1МБ (это, к примеру,
максимально допустимый объём стека вызовов, используемого для статических массивов).
Требование по времени накладывает ограничение на количество чтений исходного файла.
3.а. Реализуйте задачу сортировки числового файла с заданными условиями. Добавьте в код воз-
можность определения времени работы программы.
Примечание: содержимое входного файла должно быть сформировано неповторяющимися зна-
чениями заранее, это время не должно учитываться при замере времени сортировки.
Для упрощения кода работы с файлами в текстовом режиме можно ограничиться только семизначными числами
в диапазоне [1000000…9999999]; для работы с файлами в бинарном режиме это не актуально.
3.б. Определите программно объём оперативной памяти, занимаемый битовым массивом.