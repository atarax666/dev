#include <bitset>
#include <cstdlib>
#include <iostream>
#include <Windows.h>
#include <fstream>
#include <vector>
#include <chrono>

using namespace std;

//для заданий 3.а и 3.б. 
const int MAX_NUMBERS = 10000000; // Максимальное количество чисел
const int BIT_ARRAY_SIZE = MAX_NUMBERS / 8; // Размер битового массива в байтах

int main() {
	//Пример – как установить 5 - й бит произвольного целого числа в 0 и что получится в результате :
	//unsigned char x = 255; //8-разрядное двоичное число 11111111
	//unsigned char maska = 1; //1=00000001 – 8-разрядная маска
	//x = x & (~(maska << 4)); //результат x=239

	//Задание 1:
	//1.а. Реализуйте вышеприведённый пример, проверьте правильность результата в том числе и на
	//	   других значениях х.
	//1.б. Реализуйте по аналогии с предыдущим примером установку 7 - го бита числа в единицу.
	//1.в. Реализуйте код листинга 1, объясните выводимый программой результат.

	setlocale(LC_ALL, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	//1.а. Установка 5-го бита в 0
	unsigned char x = 255; // 8-разрядное двоичное число 11111111
	unsigned char maska = 1; // 1 = 00000001 – 8-разрядная маска
	// Сдвигаем маску на 4 разряда влево, чтобы получить 00010000
	maska = maska << 4;
	// Инвертируем маску, чтобы получить 11101111, и выполняем побитовое И с x
	x = x & (~maska);
	// Выводим результат, ожидаем 239
	cout << "Задание 1.а. Установка 5-го бита в 0." << endl;
	cout << "Результат: " << (int)x << endl;

	//1.б. Установка 7-го бита в 1
	unsigned char x = 25; // Примерное значение x
	unsigned char maska = 1; // 1 = 00000001 – 8-разрядная маска
	// Сдвигаем маску на 6 разрядов влево, чтобы получить 01000000
	maska = maska << 6;
	// Выполняем побитовое ИЛИ с x для установки 7-го бита
	x = x | maska;
	// Выводим результат
	cout << "Задание 1.б. Установка 7-го бита в 1." << endl;
	cout << "Результат: " << (int)x << endl;

	/*Задание 2:
	2.а.Реализуйте вышеописанный пример с вводом произвольного набора до 8 - ми чисел(со зна -
		чениями от 0 до 7) и его сортировкой битовым массивом в виде числа типа unsigned char.Про -
		верьте работу программы.
		Если количество чисел в исходной последовательности больше 8 и / или значения превос -
		ходят 7, можно подобрать тип беззнакового числа для битового массива с подходящим размером
		разрядной сетки – до 64 в типе unsigned long long(см.табл. 1).
	2.б.Адаптируйте вышеприведённый пример для набора из 64 - х чисел(со значениями от 0 до 63)
		с битовым массивом в виде числа типа unsigned long long.
		Если количество чисел и/или их значения превосходят возможности разрядной сетки од-
		ного беззнакового целого числа, то можно организовать линейный массив (вектор) таких чисел,
		который в памяти ЭВМ будет представлен одной непрерывной битовой последовательностью.
	2.в.Исправьте программу задания 2.б, чтобы для сортировки набора из 64-х чисел использова-
		лось не одно число типа unsigned long long, а линейный массив чисел типа unsigned char.	*/

		//2.а. Сортировка чисел от 0 до 7
	unsigned char bitArray = 0; // Изначально все биты равны 0
	int numbers[] = { 1, 0, 5, 7, 2, 4 }; // Исходная последовательность чисел
	int size = sizeof(numbers) / sizeof(numbers[0]);
	// Устанавливаем соответствующие биты в 1
	for (int i = 0; i < size; i++) {
		bitArray |= (1 << numbers[i]);
	}
	// Выводим отсортированную последовательность
	cout << "Задание 2.а. Сортировка чисел от 0 до 7." << endl;
	cout << "Отсортированные числа: ";
	for (int i = 0; i < 8; i++) {
		if (bitArray & (1 << i)) {
			cout << i << " ";
		}
	}
	cout << endl;

	//2.б. Сортировка чисел от 0 до 63
	unsigned long long bitArray = 0; // Изначально все биты равны 0
	int numbers[] = { 1, 0, 5, 7, 2, 4, 63, 32 }; // Исходная последовательность чисел
	int size = sizeof(numbers) / sizeof(numbers[0]);
	// Устанавливаем соответствующие биты в 1
	for (int i = 0; i < size; i++) {
		bitArray |= (1ULL << numbers[i]);
	}
	// Выводим отсортированную последовательность
	cout << "Задание 2.б. Сортировка чисел от 0 до 63." << endl;
	cout << "Отсортированные числа: ";
	for (int i = 0; i < 64; i++) {
		if (bitArray & (1ULL << i)) {
			cout << i << " ";
		}
	}
	cout << endl;

	//2.в. Использование массива unsigned char для сортировки
	const int numBits = 64; // Количество битов для представления чисел от 0 до 63
	const int arraySize = numBits / 8; // Размер массива в байтах (64 бита / 8 бит на байт)
	unsigned char bitArray[arraySize] = { 0 }; // Инициализируем массив байтов нулями

	int numbers[] = { 1, 0, 5, 7, 2, 4, 63, 32 }; // Исходная последовательность чисел
	int size = sizeof(numbers) / sizeof(numbers[0]); // Определяем количество элементов в массиве

	// Установка соответствующих битов в битовом массиве
	for (int i = 0; i < size; i++) {
		int index = numbers[i] / 8; // Определяем индекс байта в массиве
		int offset = numbers[i] % 8; // Определяем смещение внутри байта
		bitArray[index] |= (1 << offset); // Устанавливаем соответствующий бит в 1
	}

	// Вывод отсортированных чисел, представленных единичными битами
	cout << "Отсортированные числа: ";
	for (int i = 0; i < numBits; i++) {
		int index = i / 8; // Определяем индекс байта для текущего бита
		int offset = i % 8; // Определяем смещение внутри байта
		if (bitArray[index] & (1 << offset)) { // Проверяем, установлен ли бит
			cout << i << " "; // Если битЫ установлен, выводим соответствующее число
		}
	}
	cout << endl;

	/*Задание 3.
	Постановка задачи:
	Входные данные: файл, содержащий не более n=107 неотрицательных целых чисел2, среди них
	нет повторяющихся.
	Результат: упорядоченная по возрастанию последовательность исходных чисел в выходном
	файле.
	Время работы программы: ~10 с (до 1 мин. для систем малой вычислительной мощности).
	Максимально допустимый объём ОЗУ для хранения данных: 1 МБ.
	Очевидно, что размер входных данных гарантированно превысит 1МБ (это, к примеру,
	максимально допустимый объём стека вызовов, используемого для статических массивов).
	Требование по времени накладывает ограничение на количество чтений исходного файла.
	3.а. Реализуйте задачу сортировки числового файла с заданными условиями. Добавьте в код воз-
		можность определения времени работы программы.
		Примечание: содержимое входного файла должно быть сформировано неповторяющимися зна-
		чениями заранее, это время не должно учитываться при замере времени сортировки.
		В отчёт внесите результаты тестирования для наибольшего количества входных чисел, соответ-
		ствующего битовому массиву длиной 1МБ.
	3.б. Определите программно объём оперативной памяти, занимаемый битовым массивом.*/

	//Задание 3.а. Сортировка файла с числами и 3.б. Определение объема оперативной памяти, 
	// занимаемого битовым массивом
	bitset<MAX_NUMBERS> bitArray; // Создаем битовый массив на 10^7 бит, все биты изначально равны 0

	// Чтение чисел из файла
	ifstream inputFile("input.txt"); // Открываем файл для чтения
	if (!inputFile) {
		cout << "Ошибка открытия файла" << endl;
		return 1; // Завершаем программу, если файл не удалось открыть
	}

	int number;
	while (inputFile >> number) { // Читаем числа из файла
		bitArray.set(number); // Устанавливаем бит, соответствующий числу, в 1
	}
	inputFile.close(); // Закрываем файл после чтения

	// Открываем файл для записи отсортированных чисел
	ofstream outputFile("output.txt"); // Открываем файл для записи
	if (!outputFile) {
		cout << "Ошибка открытия файла" << endl;
		return 1; // Завершаем программу, если файл не удалось открыть
	}

	// Записываем отсортированные числа в файл
	for (int i = 0; i < MAX_NUMBERS; i++) {
		if (bitArray.test(i)) { // Проверяем, установлен ли бит
			outputFile << i << endl; // Записываем число, если бит установлен
		}
	}
	outputFile.close(); // Закрываем файл после записи

	// Определяем объем памяти, занимаемый битовым массивом
	size_t memorySize = MAX_NUMBERS / 8; // Вычисляем объем памяти в байтах
	cout << "Объем памяти под битовый массив: " << memorySize / (1024.0 * 1024.0) << " МБ" << endl;

	return 0;
}